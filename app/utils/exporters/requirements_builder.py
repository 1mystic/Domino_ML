"""
Requirements Builder - Maps ML components to Python package dependencies
"""
import re
from typing import Dict, List, Set, Tuple


class RequirementsBuilder:
    """
    Analyzes ML pipeline components and generates requirements.txt with proper package versions.
    """
    
    # Package mapping: import statement -> package name and version
    PACKAGE_MAPPING = {
        'pandas': ('pandas', '2.1.0'),
        'numpy': ('numpy', '1.24.3'),
        'sklearn': ('scikit-learn', '1.3.0'),
        'matplotlib': ('matplotlib', '3.7.2'),
        'seaborn': ('seaborn', '0.12.2'),
        'scipy': ('scipy', '1.11.1'),
        'xgboost': ('xgboost', '2.0.0'),
        'lightgbm': ('lightgbm', '4.0.0'),
        'tensorflow': ('tensorflow', '2.13.0'),
        'torch': ('torch', '2.0.1'),
        'keras': ('keras', '2.13.1'),
        'joblib': ('joblib', '1.3.1'),
        'pickle': None,  # Built-in, no package needed
        'json': None,    # Built-in
        'os': None,      # Built-in
        'sys': None,     # Built-in
    }
    
    def __init__(self):
        self.packages: Set[Tuple[str, str]] = set()
        
    def analyze_code(self, code: str) -> None:
        """
        Analyze Python code and extract required packages.
        
        Args:
            code: Python code string to analyze
        """
        # Extract import statements
        import_pattern = r'^(?:from\s+(\w+)|import\s+(\w+))'
        
        for line in code.split('\n'):
            line = line.strip()
            if line.startswith(('import ', 'from ')):
                match = re.match(import_pattern, line)
                if match:
                    module = match.group(1) or match.group(2)
                    self._add_package(module)
    
    def analyze_components(self, nodes: List[Dict]) -> None:
        """
        Analyze pipeline nodes and extract required packages from their Python templates.
        
        Args:
            nodes: List of pipeline node dictionaries
        """
        from app.utils.data_loader import get_components
        
        # Load component definitions
        comp_data = get_components()
        components_dict = {c['id']: c for c in comp_data.get('components', [])}
        
        # Analyze each node
        for node in nodes:
            component_id = node.get('data', {}).get('componentId')
            component = components_dict.get(component_id)
            
            if component and 'pythonTemplate' in component:
                self.analyze_code(component['pythonTemplate'])
    
    def _add_package(self, module: str) -> None:
        """
        Add a package based on module name.
        
        Args:
            module: Module name from import statement
        """
        if module in self.PACKAGE_MAPPING:
            package_info = self.PACKAGE_MAPPING[module]
            if package_info:  # Skip built-in modules (None)
                self.packages.add(package_info)
    
    def add_custom_package(self, package_name: str, version: str = None) -> None:
        """
        Add a custom package requirement.
        
        Args:
            package_name: Name of the package
            version: Version string (optional)
        """
        self.packages.add((package_name, version or 'latest'))
    
    def generate_requirements(self, pinned: bool = True) -> str:
        """
        Generate requirements.txt content.
        
        Args:
            pinned: Whether to pin package versions (default: True)
            
        Returns:
            String content for requirements.txt
        """
        if not self.packages:
            return "# No package dependencies found\n"
        
        lines = ["# Auto-generated requirements for ML Pipeline\n"]
        lines.append("# Generated by DominoML\n\n")
        
        # Sort packages alphabetically
        sorted_packages = sorted(self.packages, key=lambda x: x[0])
        
        for package_name, version in sorted_packages:
            if pinned and version and version != 'latest':
                lines.append(f"{package_name}=={version}")
            else:
                lines.append(package_name)
        
        return '\n'.join(lines) + '\n'
    
    def get_packages_list(self) -> List[Tuple[str, str]]:
        """
        Get list of required packages.
        
        Returns:
            List of (package_name, version) tuples
        """
        return sorted(self.packages, key=lambda x: x[0])
    
    @staticmethod
    def from_nodes(nodes: List[Dict], pinned: bool = True) -> str:
        """
        Convenience method to generate requirements from nodes directly.
        
        Args:
            nodes: List of pipeline node dictionaries
            pinned: Whether to pin package versions
            
        Returns:
            String content for requirements.txt
        """
        builder = RequirementsBuilder()
        builder.analyze_components(nodes)
        return builder.generate_requirements(pinned=pinned)
