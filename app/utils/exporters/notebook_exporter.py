"""
Notebook Exporter - Generates Jupyter notebooks from ML pipelines
"""
import json
from datetime import datetime
from typing import Dict, List
from app.utils.code_generator import topological_sort


class NotebookExporter:
    """
    Exports ML pipelines as Jupyter notebooks with proper cell structure.
    """
    
    def __init__(self):
        self.notebook_version = "4.5"
        self.kernel_spec = {
            "display_name": "Python 3",
            "language": "python",
            "name": "python3"
        }
    
    def export(
        self,
        nodes: List[Dict],
        edges: List[Dict],
        pipeline_name: str,
        description: str = ""
    ) -> str:
        """
        Export pipeline as Jupyter notebook JSON.
        
        Args:
            nodes: List of pipeline nodes
            edges: List of pipeline edges
            pipeline_name: Name of the pipeline
            description: Pipeline description
            
        Returns:
            Jupyter notebook JSON string
        """
        if not nodes:
            return self._generate_empty_notebook(pipeline_name)
        
        cells = []
        
        # Add header cell
        cells.append(self._create_markdown_cell(
            f"# {pipeline_name}\n\n{description or 'ML Pipeline'}\n\n"
            f"**Generated by DominoML**  \n"
            f"**Created:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        ))
        
        # Add setup cell
        cells.append(self._create_markdown_cell(
            "## Setup\n\nImport required libraries and configure environment."
        ))
        
        # Collect imports
        imports_cell = self._generate_imports_cell(nodes)
        cells.append(imports_cell)
        
        # Add pipeline cells
        cells.append(self._create_markdown_cell(
            "## Pipeline Execution\n\nExecute the ML pipeline step by step."
        ))
        
        # Sort nodes topologically
        sorted_nodes = topological_sort(nodes, edges)
        
        # Create cell for each step
        for index, node in enumerate(sorted_nodes):
            # Add step header
            step_name = node['data']['label']
            cells.append(self._create_markdown_cell(
                f"### Step {index + 1}: {step_name}"
            ))
            
            # Add code cell
            code_cell = self._generate_node_cell(node, index)
            cells.append(code_cell)
        
        # Add summary cell
        cells.append(self._create_markdown_cell(
            "## Results\n\nPipeline execution completed!"
        ))
        
        # Build notebook structure
        notebook = {
            "cells": cells,
            "metadata": {
                "kernelspec": self.kernel_spec,
                "language_info": {
                    "name": "python",
                    "version": "3.10.0"
                }
            },
            "nbformat": 4,
            "nbformat_minor": 5
        }
        
        return json.dumps(notebook, indent=2)
    
    def _create_markdown_cell(self, content: str) -> Dict:
        """Create a markdown cell."""
        return {
            "cell_type": "markdown",
            "metadata": {},
            "source": content.split('\n')
        }
    
    def _create_code_cell(self, code: str) -> Dict:
        """Create a code cell."""
        return {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": code.split('\n')
        }
    
    def _generate_imports_cell(self, nodes: List[Dict]) -> Dict:
        """Generate cell with all imports."""
        from app.utils.data_loader import get_components
        
        comp_data = get_components()
        components_dict = {c['id']: c for c in comp_data.get('components', [])}
        
        imports = set()
        for node in nodes:
            component_id = node.get('data', {}).get('componentId')
            component = components_dict.get(component_id)
            
            if component and 'pythonTemplate' in component:
                template_lines = component['pythonTemplate'].split('\n')
                for line in template_lines:
                    line = line.strip()
                    if line.startswith('from ') or line.startswith('import '):
                        imports.add(line)
        
        import_code = '\n'.join(sorted(imports))
        import_code += "\n\n# Configure display options\nimport warnings\nwarnings.filterwarnings('ignore')\n"
        import_code += "\n# Set up matplotlib\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-darkgrid')\n"
        
        return self._create_code_cell(import_code)
    
    def _generate_node_cell(self, node: Dict, index: int) -> Dict:
        """Generate code cell for a pipeline node."""
        from app.utils.data_loader import get_components
        
        comp_data = get_components()
        components_dict = {c['id']: c for c in comp_data.get('components', [])}
        
        component_id = node.get('data', {}).get('componentId')
        component = components_dict.get(component_id)
        
        if not component or 'pythonTemplate' not in component:
            return self._create_code_cell(f"# Step {index + 1}: {node['data']['label']}\npass")
        
        node_code = component['pythonTemplate']
        
        # Replace parameters
        if 'parameters' in node['data']:
            for key, value in node['data']['parameters'].items():
                placeholder = '{' + key + '}'
                if isinstance(value, str):
                    replacement = f"'{value}'"
                elif isinstance(value, bool):
                    replacement = 'True' if value else 'False'
                else:
                    replacement = str(value)
                node_code = node_code.replace(placeholder, replacement)
        
        # Remove import statements (already in imports cell)
        code_lines = []
        for line in node_code.split('\n'):
            if not line.strip().startswith(('import ', 'from ')):
                code_lines.append(line)
        
        clean_code = '\n'.join(code_lines).strip()
        
        return self._create_code_cell(clean_code)
    
    def _generate_empty_notebook(self, pipeline_name: str) -> str:
        """Generate empty notebook."""
        cells = [
            self._create_markdown_cell(
                f"# {pipeline_name}\n\n"
                "This is an empty pipeline. Please add components first!"
            )
        ]
        
        notebook = {
            "cells": cells,
            "metadata": {"kernelspec": self.kernel_spec},
            "nbformat": 4,
            "nbformat_minor": 5
        }
        
        return json.dumps(notebook, indent=2)
    
    @staticmethod
    def export_notebook(
        nodes: List[Dict],
        edges: List[Dict],
        pipeline_name: str,
        description: str = ""
    ) -> Dict[str, str]:
        """
        Convenience method to export notebook.
        
        Returns:
            Dictionary with 'notebook' content and 'filename'
        """
        exporter = NotebookExporter()
        notebook = exporter.export(nodes, edges, pipeline_name, description)
        
        return {
            'notebook': notebook,
            'filename': f"{pipeline_name.lower().replace(' ', '_')}.ipynb"
        }
