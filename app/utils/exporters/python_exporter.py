"""
Python Exporter - Generates standalone Python scripts from ML pipelines
"""
from datetime import datetime
from typing import Dict, List
from app.utils.code_generator import generate_python_code
from app.utils.exporters.requirements_builder import RequirementsBuilder


class PythonExporter:
    """
    Exports ML pipelines as executable Python scripts with proper structure.
    """
    
    def __init__(self):
        self.template_header = """#!/usr/bin/env python3
\"\"\"
{pipeline_name}
{description}

Generated by DominoML
Created: {created_at}
\"\"\"

import sys
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

"""
    
    def export(
        self,
        nodes: List[Dict],
        edges: List[Dict],
        pipeline_name: str,
        description: str = "",
        include_cli: bool = True
    ) -> str:
        """
        Export pipeline as Python script.
        
        Args:
            nodes: List of pipeline nodes
            edges: List of pipeline edges
            pipeline_name: Name of the pipeline
            description: Pipeline description
            include_cli: Whether to include CLI argument parsing
            
        Returns:
            Complete Python script as string
        """
        if not nodes:
            return self._generate_empty_script(pipeline_name)
        
        # Generate header
        header = self.template_header.format(
            pipeline_name=pipeline_name,
            description=description or "ML Pipeline",
            created_at=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
        
        # Generate main pipeline code
        pipeline_code = generate_python_code(nodes, edges, pipeline_name)
        
        # Extract just the code body (remove duplicate header)
        code_lines = pipeline_code.split('\n')
        # Skip the first few lines that are just comments
        start_index = 0
        for i, line in enumerate(code_lines):
            if line.strip().startswith('import') or line.strip().startswith('from'):
                start_index = i
                break
        
        body = '\n'.join(code_lines[start_index:])
        
        # Combine
        full_script = header + body
        
        # Add CLI if requested
        if include_cli:
            full_script = self._add_cli_support(full_script, pipeline_name)
        
        # Add error handling wrapper
        full_script = self._add_error_handling(full_script)
        
        return full_script
    
    def _generate_empty_script(self, pipeline_name: str) -> str:
        """Generate a minimal script when no nodes are present."""
        return f"""#!/usr/bin/env python3
\"\"\"
{pipeline_name}
Generated by DominoML
\"\"\"

def main():
    print("This is an empty pipeline. Please add components first!")
    return 1

if __name__ == "__main__":
    exit(main())
"""
    
    def _add_cli_support(self, script: str, pipeline_name: str) -> str:
        """Add command-line argument support."""
        cli_code = """
# Command-line interface
def parse_arguments():
    \"\"\"Parse command-line arguments.\"\"\"
    import argparse
    parser = argparse.ArgumentParser(
        description='{pipeline_name}'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose logging'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Perform dry run without executing'
    )
    return parser.parse_args()

def main():
    \"\"\"Main entry point with CLI support.\"\"\"
    args = parse_arguments()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("Verbose mode enabled")
    
    if args.dry_run:
        logger.info("Dry run mode - not executing pipeline")
        return 0
    
    try:
        run_ml_pipeline()
        return 0
    except Exception as e:
        logger.error(f"Pipeline failed: {{e}}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
""".format(pipeline_name=pipeline_name)
        
        # Replace the existing if __name__ == "__main__" block
        lines = script.split('\n')
        filtered_lines = []
        skip_next = False
        
        for i, line in enumerate(lines):
            if 'if __name__ ==' in line:
                skip_next = True
                continue
            if skip_next and line.strip().startswith('run_ml_pipeline'):
                continue
            skip_next = False
            filtered_lines.append(line)
        
        return '\n'.join(filtered_lines) + '\n' + cli_code
    
    def _add_error_handling(self, script: str) -> str:
        """Wrap run_ml_pipeline with error handling."""
        # Find the run_ml_pipeline function and wrap its contents
        lines = script.split('\n')
        new_lines = []
        inside_function = False
        function_indent = 0
        
        for i, line in enumerate(lines):
            if 'def run_ml_pipeline(' in line:
                inside_function = True
                function_indent = len(line) - len(line.lstrip())
                new_lines.append(line)
                # Add docstring if present
                if i + 1 < len(lines) and '"""' in lines[i + 1]:
                    new_lines.append(lines[i + 1])
                    continue
                # Add try block
                new_lines.append(' ' * (function_indent + 4) + 'try:')
                continue
            
            if inside_function and line.strip() and not line.strip().startswith('#'):
                # Check if we're at the end of the function
                current_indent = len(line) - len(line.lstrip())
                if current_indent <= function_indent and line.strip():
                    # End of function, add except block
                    new_lines.append(' ' * (function_indent + 4) + 'except Exception as e:')
                    new_lines.append(' ' * (function_indent + 8) + 'logger.error(f"Pipeline execution failed: {e}")')
                    new_lines.append(' ' * (function_indent + 8) + 'raise')
                    inside_function = False
                    new_lines.append(line)
                else:
                    # Inside function, add extra indentation
                    new_lines.append(' ' * 4 + line)
            else:
                new_lines.append(line)
        
        return '\n'.join(new_lines)
    
    @staticmethod
    def export_pipeline(
        nodes: List[Dict],
        edges: List[Dict],
        pipeline_name: str,
        description: str = "",
        include_cli: bool = True
    ) -> Dict[str, str]:
        """
        Convenience method to export pipeline with requirements.
        
        Returns:
            Dictionary with 'script' and 'requirements' keys
        """
        exporter = PythonExporter()
        script = exporter.export(nodes, edges, pipeline_name, description, include_cli)
        requirements = RequirementsBuilder.from_nodes(nodes, pinned=True)
        
        return {
            'script': script,
            'requirements': requirements,
            'filename': f"{pipeline_name.lower().replace(' ', '_')}.py"
        }
